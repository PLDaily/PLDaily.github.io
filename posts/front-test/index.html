<!doctype html>
<html lang="">

<head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.82.0" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link rel="icon" href="/images/favicon.ico" type="image/x-icon" />
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="前端单元测试 - PLDaily Blog">
    <meta name="twitter:description" content="为保证代码的质量，单元测试必不可少。本文记录自己在学习单元测试过程中的一些总结。
TDD与BDD的区别 TDD属于测试驱动开发，BDD属于行为驱动开发。个人理解其实就是TDD先写测试模块，再写主功能代码，然后能让测试模块通过测试，而BDD是先写主功能模块，z再写测试模块。详见示例
服务端代码测试 所谓服务端代码，指的就是一个node的模块，能在node的环境中运行。以一个项目为例，代码结构如下:
. ├── index.js ├── node_modules ├── package.json └── test └── test.js 前端测试框架主要是Mocha与Jasmine，这里我们选择Mocha，断言库有should、expect、chai以及node自带的assert。这里我们选择chai，chai中包含了expect、should及assert的书写风格。
npm install mocha chai --save-dev  index.js  const getNum = (value) =&amp;gt; { return value * 2 } module.exports = getNum  test.js  const chai = require(&#39;chai&#39;) const expect = chai.expect const getNum = require(&#39;../index&#39;) describe(&#39;Test&#39;, function() { it(&#39;should return 20 when the value is 10&#39;, function() { expect(getNum(10)).to.equal(20) }) }) describe用于给测试用例分组，it代表一个测试用例。">
    <meta name="twitter:site" content="https://pldaily.github.io/">
    <meta name="twitter:creator" content="">
    <meta name="twitter:image" content="https://pldaily.github.io/">
    
    
    <meta property="og:locale" content="">
    <meta property="og:type" content="article">
    <meta property="og:title" content="前端单元测试 - PLDaily Blog">
    <meta property="og:description" content="为保证代码的质量，单元测试必不可少。本文记录自己在学习单元测试过程中的一些总结。
TDD与BDD的区别 TDD属于测试驱动开发，BDD属于行为驱动开发。个人理解其实就是TDD先写测试模块，再写主功能代码，然后能让测试模块通过测试，而BDD是先写主功能模块，z再写测试模块。详见示例
服务端代码测试 所谓服务端代码，指的就是一个node的模块，能在node的环境中运行。以一个项目为例，代码结构如下:
. ├── index.js ├── node_modules ├── package.json └── test └── test.js 前端测试框架主要是Mocha与Jasmine，这里我们选择Mocha，断言库有should、expect、chai以及node自带的assert。这里我们选择chai，chai中包含了expect、should及assert的书写风格。
npm install mocha chai --save-dev  index.js  const getNum = (value) =&amp;gt; { return value * 2 } module.exports = getNum  test.js  const chai = require(&#39;chai&#39;) const expect = chai.expect const getNum = require(&#39;../index&#39;) describe(&#39;Test&#39;, function() { it(&#39;should return 20 when the value is 10&#39;, function() { expect(getNum(10)).to.equal(20) }) }) describe用于给测试用例分组，it代表一个测试用例。">
    <meta property="og:url" content="https://pldaily.github.io/posts/front-test/">
    <meta property="og:site_name" content="PLDaily Blog">
    <meta property="og:image" content="https://pldaily.github.io/">
    
    <title>前端单元测试 - PLDaily Blog</title>

    <meta name="author" content="">
    <meta name="description" content="为保证代码的质量，单元测试必不可少。本文记录自己在学习单元测试过程中的一些总结。
TDD与BDD的区别 TDD属于测试驱动开发，BDD属于行为驱动开发。个人理解其实就是TDD先写测试模块，再写主功能代码，然后能让测试模块通过测试，而BDD是先写主功能模块，z再写测试模块。详见示例
服务端代码测试 所谓服务端代码，指的就是一个node的模块，能在node的环境中运行。以一个项目为例，代码结构如下:
. ├── index.js ├── node_modules ├── package.json └── test └── test.js 前端测试框架主要是Mocha与Jasmine，这里我们选择Mocha，断言库有should、expect、chai以及node自带的assert。这里我们选择chai，chai中包含了expect、should及assert的书写风格。
npm install mocha chai --save-dev  index.js  const getNum = (value) =&amp;gt; { return value * 2 } module.exports = getNum  test.js  const chai = require(&#39;chai&#39;) const expect = chai.expect const getNum = require(&#39;../index&#39;) describe(&#39;Test&#39;, function() { it(&#39;should return 20 when the value is 10&#39;, function() { expect(getNum(10)).to.equal(20) }) }) describe用于给测试用例分组，it代表一个测试用例。">

    
    

    
    

    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
    <link rel="stylesheet" href="https://pldaily.github.io/css/theme.css">
    <link rel="stylesheet" href="https://pldaily.github.io/css/chroma.dracula.css">
</head>
<body class="font-serif bg-gray-200 border-t-4 border-blue-500 antialiased">
    <div class="w-full p-6 md:w-2/3 md:px-0 md:mx-auto xl:w-2/5">
        <header class="mb-6">
            
            <div class="mb-6 md:flex md:items-center">
                
<div>
    <a class="text-lg mb-8 inline-block" href="/">&larr; Back Home</a>

    
    
    <h1 class="text-4xl font-bold">前端单元测试</h1>
    <time datetime="2018-01-10 17:05:43 UTC">10 Jan 2018</time>
    
    
    
    <ol class="mt-4">
        
        <li class="inline-block">
            <a class="border-none text-gray-800 text-xs bg-gray-400 hover:bg-gray-600 hover:text-white rounded-sm px-3 py-1" href="https://pldaily.github.io/tags/javascript">JavaScript</a>
        </li>
        
    </ol>
    
</div>

            </div>
        </header>

        
        
<article class="mb-12">
    <p>为保证代码的质量，单元测试必不可少。本文记录自己在学习单元测试过程中的一些总结。</p>
<!-- raw HTML omitted -->
<h3 id="tdd与bdd的区别">TDD与BDD的区别</h3>
<p>TDD属于测试驱动开发，BDD属于行为驱动开发。个人理解其实就是TDD先写测试模块，再写主功能代码，然后能让测试模块通过测试，而BDD是先写主功能模块，z再写测试模块。详见<a href="https://github.com/jdavis/tdd-vs-bdd">示例</a></p>
<h3 id="服务端代码测试">服务端代码测试</h3>
<p>所谓服务端代码，指的就是一个node的模块，能在node的环境中运行。以一个项目为例，代码结构如下:</p>
<pre><code>.
├── index.js
├── node_modules
├── package.json
└── test
    └── test.js
</code></pre><p>前端测试框架主要是<a href="https://mochajs.org/">Mocha</a>与<a href="https://jasmine.github.io/">Jasmine</a>，这里我们选择Mocha，断言库有<a href="https://github.com/shouldjs/should.js">should</a>、<a href="https://github.com/Automattic/expect.js">expect</a>、<a href="http://chaijs.com/">chai</a>以及node自带的assert。这里我们选择chai，chai中包含了expect、should及assert的书写风格。</p>
<pre><code class="language-Git" data-lang="Git">npm install mocha chai --save-dev
</code></pre><ul>
<li>index.js</li>
</ul>
<pre><code>const getNum = (value) =&gt; {
  return value * 2
}

module.exports = getNum
</code></pre><ul>
<li>test.js</li>
</ul>
<pre><code>const chai = require('chai')
const expect = chai.expect
const getNum = require('../index')

describe('Test', function() {
  it('should return 20 when the value is 10', function() {
  	expect(getNum(10)).to.equal(20)
  })
})
</code></pre><p>describe用于给测试用例分组，it代表一个测试用例。</p>
<ul>
<li>package.json</li>
</ul>
<pre><code>&quot;scripts&quot;: {
  &quot;test&quot;: &quot;mocha&quot;
}
</code></pre><p> 需要在全局下安装Mocha</p>
<pre><code>npm install mocha -g
</code></pre><p>项目目录下执行</p>
<pre><code class="language-git" data-lang="git">npm run test
</code></pre><p>测试通过
<!-- raw HTML omitted --></p>
<p>完成代码测试之后我们再去看看代码测试的覆盖率。测试代码覆盖率我们选择使用<a href="https://github.com/gotwarlost/istanbul">istanbul</a>，全局安装</p>
<pre><code>npm install -g istanbul
</code></pre><p>使用istanbul启动Mocha</p>
<pre><code>istanbul cover _mocha
</code></pre><p>测试通过，覆盖率100%</p>
<!-- raw HTML omitted -->
<p>行覆盖率（line coverage）：是否每一行都执行了？
函数覆盖率（function coverage）：是否每个函数都调用了？
分支覆盖率（branch coverage）：是否每个if代码块都执行了？
语句覆盖率（statement coverage）：是否每个语句都执行了？</p>
<p>修改index.js再看代码覆盖率</p>
<pre><code>const getNum = (value) =&gt; {
  if(value === 0) {
	return 1
  }else {
	return value * 2
  }
}

module.exports = getNum
</code></pre><p>发现代码覆盖率发生了变化</p>
<!-- raw HTML omitted -->
<p>修改test.js添加测试用例</p>
<pre><code>describe('Test', function() {
  it('should return 20 when the value is 10', function() {
  	expect(getNum(10)).to.equal(20)
  })
  it('should return 1 when the value is 0', function() {
    expect(getNum(0)).to.equal(0)
  })
})
</code></pre><p>代码覆盖率又回到了100%</p>
<!-- raw HTML omitted -->
<h3 id="客户端代码">客户端代码</h3>
<p>客户端代码即运行在浏览器中的代码，代码中包含了window、document等对象，需要在浏览器环境下才能起作用。还是以一个项目为例，代码结构如下:</p>
<pre><code>.
├── index.js
├── node_modules
├── package.json
└── test
    └── test.js
    └── test.html
</code></pre><p>我们依然使用Mocha测试库及chai断言库。</p>
<pre><code>npm install mocha chai --save-dev
</code></pre><ul>
<li>index.js</li>
</ul>
<pre><code>window.createDiv = function(value) {
  var oDiv = document.createElement('div')
  oDiv.id = 'myDiv'
  oDiv.innerHTML = value
  document.body.appendChild(oDiv)
}
</code></pre><ul>
<li>test.js</li>
</ul>
<pre><code>mocha.ui('bdd')

var expect = chai.expect
describe(&quot;Tests&quot;, function () {
  before(function () {
    createDiv('test')
  })
  it(&quot;content right&quot;, function () {
    var el = document.querySelector('#myDiv')
    expect(el).to.not.equal(null)
    expect(el.innerHTML).to.equal(&quot;test&quot;)
  })
})

mocha.run()
</code></pre><ul>
<li>test.html</li>
</ul>
<pre><code>&lt;html&gt;
   &lt;head&gt;
     &lt;title&gt; Tests &lt;/title&gt;
     &lt;link rel=&quot;stylesheet&quot; href=&quot;../node_modules/mocha/mocha.css&quot;/&gt;
   &lt;/head&gt;
   &lt;body&gt;
     &lt;div id=&quot;mocha&quot;&gt;&lt;/div&gt;
     &lt;script src=&quot;../node_modules/mocha/mocha.js&quot;&gt;&lt;/script&gt;
     &lt;script src=&quot;../node_modules/chai/chai.js&quot;&gt;&lt;/script&gt;
     &lt;script src=&quot;../index.js&quot;&gt;&lt;/script&gt;
     &lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt;
   &lt;/body&gt;
 &lt;/html&gt;
</code></pre><p>直接用浏览器打开test.html文件便能看到测试结果
<img src="https://user-images.githubusercontent.com/11615211/34821773-bcf4636a-f6ff-11e7-9f92-223e31eaf553.png" alt="2018-01-11 2 15 12"></p>
<p>当然我们可以选择<a href="http://phantomjs.org/">PhantomJS</a>模拟浏览器去做测试，这里我们使用<a href="https://github.com/nathanboktae/mocha-phantomjs">mocha-phantomjs</a>对test.html做测试。</p>
<p>全局安装mocha-phantomjs</p>
<pre><code>npm install mocha-phantomjs -g
</code></pre><p>修改package.json</p>
<pre><code>&quot;scripts&quot;: {
  &quot;test&quot;: &quot;mocha-phantomjs test/test.html&quot;
}
</code></pre><p>项目目录下执行</p>
<pre><code>npm run test
</code></pre><p>mocha-phantomjs在mac下执行会报<code>phantomjs terminated with signal SIGSEGV</code>，暂时没有找到什么解决方案。所以我在ubuntu下执行，结果显示如图</p>
<p><img src="https://user-images.githubusercontent.com/11615211/34821810-db0fd622-f6ff-11e7-8f80-53eda337076b.png" alt="2018-01-11 2 31 45"></p>
<p>上述方式虽然能完成代码的单元测试，但是要完成代码覆盖率的计算也没有什么好的方式，所以我选择引入测试管理工具<a href="https://karma-runner.github.io/2.0/index.html">karma</a></p>
<h3 id="karma使用指南">karma使用指南</h3>
<p>略去一大堆介绍karma的废话，项目下引入karma</p>
<pre><code>npm install karma --save-dev
</code></pre><p>初始化配置karma配置文件</p>
<pre><code>npm install karma -g
karma init
</code></pre><p>使用karma默认配置看看每一项的作用</p>
<ul>
<li>Karma.conf.js</li>
</ul>
<pre><code>module.exports = function(config) {
  config.set({
    basePath: '', // 设置根目录
    frameworks: ['jasmine'], // 测试框架
    files: [ // 浏览器中加载的文件
    ],
    exclude: [ // 浏览器中加载的文件中排除的文件
    ],
    preprocessors: { // 预处理
    },
    reporters: ['progress'], // 添加额外的插件
    port: 9876, // 开启测试服务时监听的端口
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true, // 监听文件变化，发生变化则重新编译
    browsers: ['Chrome'], // 测试的浏览器
    singleRun: false, // 执行测试用例后是否关闭测试服务
    concurrency: Infinity
  })
}
</code></pre><p>此时的项目结构如下所示</p>
<pre><code>.
├── index.js
├── node_modules
├── package.json
├── karma.conf.js
└── test
    └── test.js
</code></pre><p>首先我们将测试框架jasmine改为我们熟悉的mocha及chai，添加files及plugins</p>
<pre><code>npm install karma karma-mocha karma-chai mocha chai karma-chrome-launcher --save-dev
</code></pre><ul>
<li>karma.conf.js</li>
</ul>
<pre><code>module.exports = function(config) {
  config.set({
    basePath: '',
    frameworks: ['mocha', 'chai'],
    files: [
        'index.js',
        'test/*.js'
    ],
    exclude: [
    ],
    preprocessors: {
    },
    reporters: ['progress'],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true,
    browsers: ['Chrome'],
    singleRun: false,
    concurrency: Infinity,
    plugins: [
      'karma-chrome-launcher',
      'karma-mocha',
      'karma-chai',
    ]
  })
}
</code></pre><p>全局安装karma-cli</p>
<pre><code>npm install -g karma-cli
</code></pre><p>修改package.json</p>
<pre><code>&quot;scripts&quot;: {
  &quot;test&quot;: &quot;karma start karma.conf.js&quot;
}
</code></pre><p>执行npm run test便可以启用chrome去加载页面。</p>
<!-- raw HTML omitted -->
<h3 id="karma测试代码覆盖率">karma测试代码覆盖率</h3>
<p>测试代码覆盖率，我们还是选择使用PhantomJS模拟浏览器，将<code>singleRun</code>设为<code>true</code>，即执行完测试用例就退出测试服务。</p>
<pre><code>npm install karma-phantomjs-launcher --save-dev
</code></pre><p>将<code>browsers</code>中的<code>Chrome</code>改为<code>PhantomJS</code>，<code>plugins</code>中的<code>karma-chrome-launcher</code>改为<code>karma-phantomjs-launcher</code></p>
<p>执行npm run test ，测试通过且自动退出如图所示</p>
<!-- raw HTML omitted -->
<p>引入karma代码覆盖率模块karma-coverage，改模块依赖于istanbul</p>
<pre><code>npm install istanbul karma-coverage --save-dev
</code></pre><p>修改karma.conf.js</p>
<pre><code>module.exports = function(config) {
  config.set({
    basePath: '',
    frameworks: ['mocha', 'chai'],
    files: [
        'index.js',
        'test/*.js'
    ],
    exclude: [
    ],
    preprocessors: {
        'index.js': ['coverage']
    },
    reporters: ['progress', 'coverage'],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true,
    browsers: ['PhantomJS'],
    singleRun: true,
    concurrency: Infinity,
    coverageReporter: {
      type : 'text-summary'
    },
    plugins: [
      'karma-phantomjs-launcher',
      'karma-mocha',
      'karma-coverage',
      'karma-chai',
    ]
  })
}
</code></pre><p>对index.js文件使用coverage进行预处理，加入karma-coverage插件，覆盖率测试输出coverageReporter配置，详见<a href="https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md">这里</a>这里为了方便截图显示将其设为<code>text-summary</code></p>
<p>执行npm run test，显示结果如下图所示</p>
<!-- raw HTML omitted -->
<h3 id="es6代码覆盖率计算">ES6代码覆盖率计算</h3>
<p>目前的浏览器并不能兼容所有ES6代码，所以ES6代码都需要经过babel编译后才可在浏览器环境中运行，但编译后的代码webpack会加入许多其他的模块，对编译后的代码做测试覆盖率就没什么意义了。</p>
<ul>
<li>index.js</li>
</ul>
<pre><code>const createDiv = value =&gt; {
  var oDiv = document.createElement('div')
  oDiv.id = 'myDiv'
  oDiv.innerHTML = value
  document.body.appendChild(oDiv)
}

module.exports = createDiv
</code></pre><p>我们使用ES6中的箭头函数</p>
<ul>
<li>test.js</li>
</ul>
<pre><code>const createDiv = require('../index')
describe(&quot;Tests&quot;, function () {
  before(function () {
    createDiv('test')
  })
  it(&quot;content right&quot;, function () {
    var el = document.querySelector('#myDiv')
    expect(el).to.not.equal(null)
    expect(el.innerHTML).to.equal(&quot;test&quot;)
  })
})
</code></pre><ul>
<li>kama.conf.js</li>
</ul>
<pre><code>module.exports = function(config) {
  config.set({
    basePath: '',
    frameworks: ['mocha', 'chai'],
    files: [
        'test/*.js'
    ],
    exclude: [
    ],
    preprocessors: {
        'index.js': ['coverage'],
        'test/*.js': ['webpack']
    },
    reporters: ['progress', 'coverage'],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true,
    browsers: ['PhantomJS'],
    singleRun: true,
    concurrency: Infinity,
    coverageReporter: {
      type : 'text-summary'
    },
    webpack: {
      module: {
        rules: [
          {
            test: /\.js$/,
            exclude: /node_modules/,
            use: {
              loader: 'babel-loader',
              options: {
                &quot;presets&quot;: [&quot;es2015&quot;],
                &quot;plugins&quot;: [[&quot;istanbul&quot;]]
              }
            }
          }
        ]
      }
    },
    plugins: [
      'karma-phantomjs-launcher',
      'karma-mocha',
      'karma-coverage',
      'karma-webpack',
      'karma-chai',
    ]
  })
}
</code></pre><p>test.js文件通过require引入index.js文件，所以files只需引入test.js文件，再对test.js做webpack预处理。</p>
<p>需要相关的babel，webpack，karma依赖如下：</p>
<pre><code>&quot;devDependencies&quot;: {
  &quot;babel-core&quot;: &quot;^6.26.0&quot;,
  &quot;babel-loader&quot;: &quot;^7.1.2&quot;,
  &quot;babel-plugin-istanbul&quot;: &quot;^4.1.5&quot;,
  &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,
  &quot;chai&quot;: &quot;^4.1.2&quot;,
  &quot;istanbul&quot;: &quot;^0.4.5&quot;,
  &quot;karma&quot;: &quot;^2.0.0&quot;,
  &quot;karma-chai&quot;: &quot;^0.1.0&quot;,
  &quot;karma-coverage&quot;: &quot;^1.1.1&quot;,
  &quot;karma-mocha&quot;: &quot;^1.3.0&quot;,
  &quot;karma-phantomjs-launcher&quot;: &quot;^1.0.4&quot;,
  &quot;karma-webpack&quot;: &quot;^2.0.9&quot;,
  &quot;mocha&quot;: &quot;^4.1.0&quot;,
  &quot;webpack&quot;: &quot;^3.10.0&quot;
}
</code></pre><p>执行npm run dev显示如图所示</p>
<!-- raw HTML omitted -->
<h3 id="travisci及coveralls">travisCI及coveralls</h3>
<p>travisCI的配置这里不做详解，我们将通过代码测试覆盖率上传到coveralls获取一个covarage的icon。</p>
<p><img src="https://user-images.githubusercontent.com/11615211/34821915-1b098d68-f700-11e7-9650-2cb7a0e0b920.png" alt="2018-01-11 6 29 18"></p>
<p>如果你是服务端代码使用istanbul计算代码覆盖率的</p>
<ul>
<li>.travis.yml</li>
</ul>
<pre><code>language: node_js
node_js:
- 'stable'
- 8
branches:
  only:
  - master
install:
- npm install
script:
- npm test
after_script: &quot;npm install coveralls &amp;&amp; cat ./coverage/lcov.info | coveralls&quot;
</code></pre><p>如果你是服务端代码使用karma计算代码覆盖率的，则需使用coveralls模块</p>
<pre><code>npm install coveralls karma-coveralls --save-dev
</code></pre><ul>
<li>Karma.conf.js</li>
</ul>
<pre><code>// Karma configuration
module.exports = function(config) {
  config.set({
    basePath: '',
    frameworks: ['mocha', 'chai'],
    files: [
      'test/*.js'
    ],
    exclude: [],
    preprocessors: {
      'test/*.js': ['webpack'],
      'index.js': ['coverage']
    },
    reporters: ['progress', 'coverage', 'coveralls'],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true,
    browsers: ['PhantomJS'],
    singleRun: true,
    concurrency: Infinity,
    webpack: {
      module: {
        rules: [
          {
            test: /\.js$/,
            exclude: /node_modules/,
            use: {
              loader: 'babel-loader',
              options: {
                &quot;presets&quot;: [&quot;es2015&quot;],
                &quot;plugins&quot;: [[&quot;istanbul&quot;], [&quot;transform-runtime&quot;]]
              }
            }
          }
        ]
      }
    },
    coverageReporter: {
      type : 'lcov',
      dir : 'coverage/'
    },
    plugins: [
      'karma-webpack',
      'karma-phantomjs-launcher',
      'karma-coverage',
      'karma-mocha',
      'karma-chai',
      'karma-coveralls'
    ],
  })
}
</code></pre><p>plugins添加karma-coveralls，reporters添加coveralls，coverageReporter输出配置改为lcov。</p>
<p>可以参考我自己实现的一个<a href="https://github.com/PLDaily/show-toast">show-toast</a>库</p>
<h3 id="参考">参考</h3>
<p><a href="https://github.com/tmallfe/tmallfe.github.io/issues/37">https://github.com/tmallfe/tmallfe.github.io/issues/37</a>
<a href="https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd/">https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd/</a>
<a href="https://github.com/jdavis/tdd-vs-bdd">https://github.com/jdavis/tdd-vs-bdd</a>
<a href="https://jasmine.github.io/">https://jasmine.github.io/</a>
<a href="https://github.com/bbraithwaite/karma-seed">https://github.com/bbraithwaite/karma-seed</a>
<a href="https://mochajs.org/">https://mochajs.org/</a>
<a href="https://toutiao.io/posts/564973/app_preview">https://toutiao.io/posts/564973/app_preview</a>
<a href="https://coveralls.io/">https://coveralls.io/</a>
<a href="https://karma-runner.github.io/0.13/index.html">https://karma-runner.github.io/0.13/index.html</a>
<a href="https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md">https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md</a>
<a href="https://shouldjs.github.io/">https://shouldjs.github.io/</a>
<a href="https://juejin.im/post/59807358518825563e037e3c">https://juejin.im/post/59807358518825563e037e3c</a>
<a href="http://www.bradoncode.com/blog/2015/02/27/karma-tutorial/">http://www.bradoncode.com/blog/2015/02/27/karma-tutorial/</a>
<a href="http://docs.casperjs.org/en/latest/quickstart.html">http://docs.casperjs.org/en/latest/quickstart.html</a>
<a href="https://github.com/gotwarlost/istanbul">https://github.com/gotwarlost/istanbul</a>
<a href="https://www.jianshu.com/p/ffd6d319f05b">https://www.jianshu.com/p/ffd6d319f05b</a>
<a href="http://www.bijishequ.com/detail/436708">http://www.bijishequ.com/detail/436708</a>
<a href="http://phantomjs.org/">http://phantomjs.org/</a>
<a href="https://github.com/CurtisHumphrey/es6-library-boilerplate">https://github.com/CurtisHumphrey/es6-library-boilerplate</a>
<a href="http://www.jackpu.com/shi-yong-babel-jspm-karma-jasmine-istanbul-shi-xian-es6-ce-shi-fu-gai-lu/">http://www.jackpu.com/shi-yong-babel-jspm-karma-jasmine-istanbul-shi-xian-es6-ce-shi-fu-gai-lu/</a>
<a href="https://github.com/JackPu/JavaScript-Algorithm-Learning">https://github.com/JackPu/JavaScript-Algorithm-Learning</a>
<a href="https://github.com/caitp/karma-coveralls">https://github.com/caitp/karma-coveralls</a>
<a href="https://github.com/karma-runner/karma-coverage">https://github.com/karma-runner/karma-coverage</a></p>


    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "pldaily" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>


        <footer class="md:flex md:justify-between">
          <span>
            &copy; 2021 PLDaily. All rights reserved.
          </span>
          <a target="_blank" rel="noopener noreferrer" href="/rss.xml" class="rss">RSS</a>
        </footer>

    </div>

    
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?e898bcadd9e22a66fbaed4a257987246";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
</body>
</html>
